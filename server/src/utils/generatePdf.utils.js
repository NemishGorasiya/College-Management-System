import { format } from 'date-fns';
import fs from 'fs';
import path from 'path';
import PDFDocument from 'pdfkit-table';
import { __dirname } from '../../paths.config.js';
import cloudinary from '../config/cloudinary.config.js';
import CustomError from '../errors/CustomError.js';
import data from './arrayData.utils.cjs';

export const generateTimetablePdfCloud = async (data) => {
    return new Promise(async (resolve, reject) => {
        // Create a new PDF document
        const doc = new PDFDocument();

        try {
            // Pipe the PDF content to a file
            const PATH_TO_FILE = (data.filename || `${data.user.fullName}_exams.pdf`);
            const uploadStream = cloudinary.uploader.upload_stream({
                resource_type: "auto",
                folder: `ClgMgmtSys/${data.user._id}`,
                filename_override: PATH_TO_FILE,
                optimize: true,
                allowed_formats: ["jpeg", "jpg", "png", "gif", "auto", "pdf", "csv", "json"],
            }, async (err, result) => {
                if (err) {
                    reject(new CustomError(err.http_code, err.message));
                }

                resolve(result);
            })

            // Add a title to the PDF
            doc.fontSize(10).text('L.D. College Of Engineering', {
                align: 'center'
            });
            doc.moveDown();

            const tableData = data.exams;

            //group the data into name of the exam
            const groupedNameData = tableData.reduce((acc, curr) => {
                if (!acc[curr.name]) {
                    acc[curr.name] = [];
                }

                acc[curr.name].push(curr);

                return acc; // return the accumulator for the next iteration of reduce function
            }, {});

            for (let key in groupedNameData) {
                doc.text(key).fontSize(10).font('Helvetica-Bold');
                doc.moveDown();

                const table = {
                    headers: ["Subject Name", "Subject Code", "Exam Name", "Date", "Duration", "Total Marks", "Coordinator"],
                    rows: groupedNameData[key].map(row => [row.subject.name, row.subject.subjectCode, row.examType, format(row.date, "dd-mm-yyyy EEEE"), row.duration, row.totalMarks, row.faculty.fullName])
                }

                const columnWidths = [150, 50, 80, 100, 50, 50, 150];

                await doc.table(table, {
                    prepareHeader: () => doc.font('Helvetica-Bold').fontSize(8),
                    prepareRow: (row, i) => doc.font('Helvetica').fontSize(8),
                    columnWidths,
                    layout: 'lightHorizontalLines' // 'noBorders', 'headerLineOnly', 'lightHorizontalLines'
                }, {
                    width: 900,
                    align: 'center'
                });
            };

            doc.moveDown();
            doc.text("Generated by: College Management System at " + format(new Date(), "dd-MM-yyyy HH:mm:ss"));
            doc.moveDown();
            doc.text(`Generated for ${data.user.fullName} with email: ${data.user.email}`)


            // Finalize PDF document
            doc.end();

            doc.pipe(uploadStream, { end: true })
        } catch (error) {
            console.log(error);
        }
    })
};

export const generateTimetablePdf = async (data) => {
    return new Promise(async (resolve, reject) => {
        // Create a new PDF document
        const doc = new PDFDocument();

        try {
            // Pipe the PDF content to a file
            const PATH_TO_FILE = path.join(__dirname, `/pdfs/`, (data.filename || `${data.user.fullName}_exams.pdf`));

            if (fs.existsSync(PATH_TO_FILE)) {
                resolve(PATH_TO_FILE);
            }

            const writeStream = fs.createWriteStream(PATH_TO_FILE);

            // Add a title to the PDF
            doc.fontSize(10).text('L.D. College Of Engineering', {
                align: 'center'
            });
            doc.moveDown();

            const tableData = data.exams;

            //group the data into name of the exam
            const groupedNameData = tableData.reduce((acc, curr) => {
                if (!acc[curr.name]) {
                    acc[curr.name] = [];
                }

                acc[curr.name].push(curr);

                return acc; // return the accumulator for the next iteration of reduce function
            }, {});

            for (let key in groupedNameData) {
                doc.text(key).fontSize(10).font('Helvetica-Bold');
                doc.moveDown();

                const table = {
                    headers: ["Subject Name", "Subject Code", "Exam Name", "Date", "Duration", "Total Marks", "Coordinator"],
                    rows: groupedNameData[key].map(row => [row.subject.name, row.subject.subjectCode, row.examType, format(row.date, "dd-mm-yyyy EEEE"), row.duration, row.totalMarks, row.faculty.fullName])
                }

                const columnWidths = [150, 50, 80, 100, 50, 50, 150];

                await doc.table(table, {
                    prepareHeader: () => doc.font('Helvetica-Bold').fontSize(8),
                    prepareRow: (row, i) => doc.font('Helvetica').fontSize(8),
                    columnWidths,
                    layout: 'lightHorizontalLines' // 'noBorders', 'headerLineOnly', 'lightHorizontalLines'
                }, {
                    width: 900,
                    align: 'center'
                });
            };

            doc.moveDown();
            doc.text("Generated by: College Management System at " + format(new Date(), "dd-MM-yyyy HH:mm:ss"));
            doc.moveDown();
            doc.text(`Generated for ${data.user.fullName} with email: ${data.user.email}`)


            // Finalize PDF document
            doc.end();

            doc.pipe(writeStream, { end: true })

            resolve(PATH_TO_FILE)
        } catch (error) {
            reject(error);
        }
    })
};

export const generateFinalResultPdf = (data) => {
    return new Promise(async (resolve, reject) => {
        try {

            const { user, finalResult, filename } = data;

            const doc = new PDFDocument();

            const PATH_TO_FILE = path.join(__dirname, `/pdfs/`, (filename || `${user.fullName}_final_result.pdf`));

            if (fs.existsSync(PATH_TO_FILE)) {
                resolve(PATH_TO_FILE);
            };

            doc.fontSize(20).text('L.D. College Of Engineering', { align: 'center' });

            doc.moveDown();

            doc.fontSize(16).text('Final Result', { align: 'center' });

            doc.moveDown();

            doc.fontSize(10).text(`Name: ${user.fullName}`);
            doc.moveDown();
            doc.fontSize(10).text(`Email: ${user.email} \n Enrollment No: ${user.enrollmentNumber} \n  Semester: ${finalResult.semester}`);
            doc.moveDown();
            doc.fontSize(10).text(`Department: ${finalResult.student.department.name}`);
            doc.moveDown();
            doc.fontSize(10).text(`Achieved Marks: ${finalResult.achievedMarks}`);
            doc.moveDown();
            doc.fontSize(10).text(`Total Marks: ${finalResult.totalMarks}`);
            doc.moveDown();
            doc.fontSize(10).text(`Percentage: ${finalResult.percentage.toFixed(2)}%`);
            doc.moveDown();
            doc.fontSize(10).text(`Grade: ${finalResult.grade}`);
            doc.moveDown();
            doc.fontSize(10).text(`SPI: ${finalResult.spi.toFixed(2)}`);
            doc.moveDown();

            // Add exam results table
            const tableData = finalResult.examResults.map(result => [
                result.exam.name,
                result.exam.subject.name,
                result.marks,
                result.exam.totalMarks,
                result.percentage.toFixed(2) + "%",
                result.grade
            ]);

            doc.fontSize(10).text('Exam Results', { align: 'center' }); // Add a title to the PDF
            doc.moveDown();

            const table = {
                headers: ["Exam Name", "Subject Name", "Marks", "Total Marks", "Percentage", "Grade"],
                rows: tableData,
                font: 'Helvetica-Bold',
                fontSize: 10,
            };

            const columnWidths = [150, 150, 50, 50, 50, 50];

            await doc.table(table, {
                prepareHeader: () => doc.font('Helvetica-Bold').fontSize(8),
                prepareRow: (row, i) => doc.font('Helvetica').fontSize(8),
                columnWidths,
                layout: 'lightHorizontalLines' // 'noBorders', 'headerLineOnly', 'lightHorizontalLines'
            }, {
                width: 500,
                align: 'center'
            });

            doc.end();

            const buffer = doc.read();

            fs.writeFileSync(PATH_TO_FILE, buffer);

            resolve(PATH_TO_FILE);
        } catch (err) {
            reject(err);
        }
    })
};