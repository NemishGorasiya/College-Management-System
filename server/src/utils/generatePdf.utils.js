import { v2 as cloudinary } from 'cloudinary';
import { format } from 'date-fns';
import fs from 'fs';
import path from 'path';
import PDFDocument from 'pdfkit-table';
import { __dirname } from '../../paths.config.js';
import CustomError from '../errors/CustomError.js';

cloudinary.config({
    cloud_name: 'dhjo1bmn7',
    api_key: '791439462714441',
    api_secret: 'wvDK2HBaTYa_PTc7Tm9N-IS_7qY',
})

export const generatePdfCloud = async (data) => {
    return new Promise(async (resolve, reject) => {
        // Create a new PDF document
        const doc = new PDFDocument();

        try {
            // Pipe the PDF content to a file
            const PATH_TO_FILE = (data.filename || `${data.user.fullName}_exams.pdf`);
            const uploadStream = cloudinary.uploader.upload_stream({
                resource_type: "auto",
                folder: `ClgMgmtSys/${data.user._id}`,
                filename_override: PATH_TO_FILE,
                optimize: true,
                allowed_formats: ["jpeg", "jpg", "png", "gif", "auto", "pdf", "csv", "json"],
            }, async (err, result) => {
                if (err) {
                    reject(new CustomError(err.http_code, err.message));
                }

                resolve(result);
            })

            // Add a title to the PDF
            doc.fontSize(12).text('L.D. College Of Engineering', {
                align: 'center'
            });
            doc.moveDown();

            const tableData = data.exams;

            //group the data into name of the exam
            const groupedNameData = tableData.reduce((acc, curr) => {
                if (!acc[curr.name]) {
                    acc[curr.name] = [];
                }

                acc[curr.name].push(curr);

                return acc; // return the accumulator for the next iteration of reduce function
            }, {});

            for (let key in groupedNameData) {
                doc.text(key).fontSize(10).font('Helvetica-Bold');
                doc.moveDown();

                const table = {
                    headers: ["Subject Name", "Subject Code", "Exam Name", "Date", "Duration", "Total Marks", "Coordinator"],
                    rows: groupedNameData[key].map(row => [row.subject.name, row.subject.subjectCode, row.examType, format(row.date, "dd-mm-yyyy EEEE"), row.duration, row.totalMarks, row.faculty.fullName])
                }

                const columnWidths = [150, 50, 80, 100, 50, 50, 150];

                await doc.table(table, {
                    prepareHeader: () => doc.font('Helvetica-Bold').fontSize(8),
                    prepareRow: (row, i) => doc.font('Helvetica').fontSize(8),
                    columnWidths,
                    layout: 'lightHorizontalLines' // 'noBorders', 'headerLineOnly', 'lightHorizontalLines'
                }, {
                    width: 900,
                    align: 'center'
                });
            };

            doc.moveDown();
            doc.text("Generated by: College Management System at " + format(new Date(), "dd-MM-yyyy HH:mm:ss"));
            doc.moveDown();
            doc.text(`Generated for ${data.user.fullName} with email: ${data.user.email}`)


            // Finalize PDF document
            doc.end();

            doc.pipe(uploadStream, { end: true })
        } catch (error) {
            console.log(error);
        }
    })
};

export const generatePdf = async (data) => {
    return new Promise(async (resolve, reject) => {
        // Create a new PDF document
        const doc = new PDFDocument();

        try {
            // Pipe the PDF content to a file
            const PATH_TO_FILE = path.join(__dirname, `/pdfs/`, (data.filename || `${data.user.fullName}_exams.pdf`));
            const writeStream = fs.createWriteStream(PATH_TO_FILE);

            // Add a title to the PDF
            doc.fontSize(12).text('L.D. College Of Engineering', {
                align: 'center'
            });
            doc.moveDown();

            const tableData = data.exams;

            //group the data into name of the exam
            const groupedNameData = tableData.reduce((acc, curr) => {
                if (!acc[curr.name]) {
                    acc[curr.name] = [];
                }

                acc[curr.name].push(curr);

                return acc; // return the accumulator for the next iteration of reduce function
            }, {});

            for (let key in groupedNameData) {
                doc.text(key).fontSize(10).font('Helvetica-Bold');
                doc.moveDown();

                const table = {
                    headers: ["Subject Name", "Subject Code", "Exam Name", "Date", "Duration", "Total Marks", "Coordinator"],
                    rows: groupedNameData[key].map(row => [row.subject.name, row.subject.subjectCode, row.examType, format(row.date, "dd-mm-yyyy EEEE"), row.duration, row.totalMarks, row.faculty.fullName])
                }

                const columnWidths = [150, 50, 80, 100, 50, 50, 150];

                await doc.table(table, {
                    prepareHeader: () => doc.font('Helvetica-Bold').fontSize(8),
                    prepareRow: (row, i) => doc.font('Helvetica').fontSize(8),
                    columnWidths,
                    layout: 'lightHorizontalLines' // 'noBorders', 'headerLineOnly', 'lightHorizontalLines'
                }, {
                    width: 900,
                    align: 'center'
                });
            };

            doc.moveDown();
            doc.text("Generated by: College Management System at " + format(new Date(), "dd-MM-yyyy HH:mm:ss"));
            doc.moveDown();
            doc.text(`Generated for ${data.user.fullName} with email: ${data.user.email}`)


            // Finalize PDF document
            doc.end();

            doc.pipe(writeStream, { end: true })

            resolve(PATH_TO_FILE)
        } catch (error) {
            reject(error);
        }
    })
}